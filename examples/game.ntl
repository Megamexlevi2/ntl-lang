const require(ntl, game)

val { Vec2, Rect, Color, EntityManager, EventBus, StateMachine, math, GameLoop } = game

val events = new EventBus()
val entities = new EntityManager()

fn createPlayer(x, y) {
  val id = entities.create({
    position: new Vec2(x, y),
    velocity: Vec2.zero(),
    size: new Vec2(32, 32),
    color: Color.blue(),
    health: 100,
    speed: 200
  })
  return id
}

fn createEnemy(x, y) {
  val id = entities.create({
    position: new Vec2(x, y),
    velocity: Vec2.zero(),
    size: new Vec2(24, 24),
    color: Color.red(),
    health: 30,
    speed: 80,
    ai: { target: null, state: "patrol" }
  })
  return id
}

val playerId = createPlayer(100, 100)
val enemy1 = createEnemy(400, 200)
val enemy2 = createEnemy(600, 300)

console.log("Player created with id:", playerId)
console.log("Enemies created:", enemy1, enemy2)

val player = entities.get(playerId)
val pos = player.components.position
console.log("Player position:", pos.toString())

pos.x = pos.x + 50
pos.y = pos.y + 30
console.log("Player moved to:", pos.toString())

val enemies = entities.query("health", "ai")
console.log("Active enemies:", enemies.length)

val distance = pos.distance(entities.get(enemy1).components.position)
console.log("Distance to enemy1:", Math.round(distance))

val states = new StateMachine({
  idle:    { enter: () => console.log("[State] -> Idle"), update: (dt) => null },
  running: { enter: () => console.log("[State] -> Running"), update: (dt) => null },
  dead:    { enter: () => console.log("[State] -> Dead"), update: () => null }
}, "idle")

states.transition("running")
states.update(0.016)
states.transition("dead")

events.on("player:damage", (data) => {
  console.log("Player took " + data.amount + " damage!")
})

events.emit("player:damage", { amount: 25 })

val clamped = math.clamp(150, 0, 100)
val lerped = math.lerp(0, 100, 0.75)
val rand = math.randInt(1, 10)
console.log("Clamp(150,0,100):", clamped)
console.log("Lerp(0,100,0.75):", lerped)
console.log("Random(1-10):", rand)
