type UserId = string
type Status = "active" | "inactive" | "banned"

class User {
  init(id: UserId, name: string, email: string) {
    this.id = id
    this.name = name
    this.email = email
    this.status = "active"
    this.createdAt = new Date()
  }

  activate() { this.status = "active"; return this }
  deactivate() { this.status = "inactive"; return this }
  ban() { this.status = "banned"; return this }
  isActive() { return this.status === "active" }

  toJSON() {
    return { id: this.id, name: this.name, email: this.email, status: this.status }
  }

  toString() { return "User(" + this.name + ", " + this.status + ")" }
}

class AdminUser extends User {
  init(id, name, email, permissions) {
    super.init(id, name, email)
    this.permissions = permissions || []
    this.role = "admin"
  }

  hasPermission(perm) { return this.permissions.includes(perm) }

  addPermission(perm) {
    unless this.hasPermission(perm) {
      this.permissions.push(perm)
    }
    return this
  }
}

val alice = new User("u1", "Alice", "alice@example.com")
val bob = new AdminUser("u2", "Bob", "bob@example.com", ["read", "write"])

console.log(alice.toString())
console.log("Bob is admin:", bob.role)
bob.addPermission("delete")
console.log("Bob permissions:", bob.permissions)

alice.deactivate()
console.log("Alice active:", alice.isActive())

async fn fetchUser(id: string): User {
  return new Promise((resolve) => {
    setTimeout(() => resolve(new User(id, "Remote User", "remote@example.com")), 10)
  })
}

async fn main() {
  val user = await fetchUser("u99")
  console.log("Fetched:", user.toString())

  val users = [alice, bob, user]
  val active = users.filter(u => u.isActive())
  console.log("Active users:", active.length)

  val names = users.map(u => u.name)
  console.log("All names:", names)

  val result = names |> (arr => arr.sort()) |> (arr => arr.join(", "))
  console.log("Sorted names:", result)
}

main()

enum Permission { Read, Write, Delete, Admin }

val perm = Permission.Write
match perm {
  case Permission.Read   => console.log("Read only")
  case Permission.Write  => console.log("Can write")
  case Permission.Delete => console.log("Can delete")
  case Permission.Admin  => console.log("Full access")
  default               => console.log("Unknown")
}

fn safeDivide(a: number, b: number) {
  unless b {
    throw new Error("Division by zero")
  }
  return a / b
}

try {
  console.log("10 / 2 =", safeDivide(10, 2))
  console.log("10 / 0 =", safeDivide(10, 0))
} catch e {
  console.log("Error:", e.message)
}

val data = null
ifset data as d {
  console.log("Data:", d)
} else {
  console.log("No data available")
}

val config = {
  host: "localhost",
  port: 3000,
  db: { name: "mydb", pool: 5 }
}

val { host, port, db: { name: dbName } } = config
console.log("Config:", host + ":" + port + "/" + dbName)
